---
name: spring-jpa-entity-design
description: Design and implement safe, optimized Spring Data JPA Entity code based on requirements or ERDs.
argument-hint: "[구현할 엔티티의 이름이나 속성, 또는 ERD 텍스트 (예: User와 Post 엔티티 만들어줘)]"
source: "custom"
tags: ["java", "spring-boot", "jpa", "database", "backend"]
triggers:
  - "엔티티 설계"
  - "엔티티 만들어"
---

# Spring Data JPA Entity Design

Detailed instructions for designing database schemas and implementing robust Spring Data JPA entities.

## Overview

- Use when modeling a new domain and designing database tables from scratch.
- Focuses on generating safe and optimized entities, fundamentally preventing common anti-patterns such as the N+1 problem or `NullPointerException` in collections.

## When to Use This Skill

- When starting a new feature that requires a new database table.
- When defining or modifying relationships (e.g., 1:N, N:M) between existing domain entities.
- When converting an ERD generated by the `database-erd-design` skill into actual entity code.

## How It Works

### Step 1: [Define Base Auditing Entity]
Create an abstract `BaseEntity` class that automatically manages `createdAt` and `updatedAt` audit fields using `@MappedSuperclass` and `@EntityListeners(AuditingEntityListener.class)`. **You must strictly use the `jakarta.persistence.*` package; NEVER use `javax.*`.**

### Step 2: [Implement Entity Class]
Create the domain class and add the `@Entity` annotation. Explicitly define the table name using a plural noun with `@Table(name = "table_names")`. You must add `@NoArgsConstructor(access = AccessLevel.PROTECTED)` for safe JPA proxy object instantiation.

### Step 3: [Map Columns and Primary Keys]
Define the primary key using `@Id` and `@GeneratedValue(strategy = GenerationType.IDENTITY)`. Specify constraints using `@Column`. Unless you specifically need to avoid reserved keyword conflicts, omit hardcoding `@Column(name="...")` and rely on Spring Boot's default snake_case naming conversion strategy.

### Step 4: [Define Relationships & Collections]
Carefully define relationships (`@ManyToOne`, `@OneToMany`, `@OneToOne`).
- **CRITICAL: You must explicitly specify `fetch = FetchType.LAZY` on all `@ManyToOne` and `@OneToOne` annotations.**
- For `@OneToMany`, immediately initialize the collection as an empty collection upon declaration (e.g., `= new ArrayList<>()`).
- For bidirectional relationships, write a 'Convenience Method' in the parent entity to safely synchronize the state of both objects.

## Examples

```java
// 1. Base Auditing Entity
@Getter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;
}

// 2. Domain Entity
@Entity
@Table(name = "documents")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Document extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String title;

    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User author;

    @OneToMany(mappedBy = "document", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Comment> comments = new ArrayList<>();

    @Builder
    public Document(String title, String content, User author) {
        this.title = title;
        this.content = content;
        this.author = author;
    }

    public void updateContent(String title, String content) {
        this.title = title;
        this.content = content;
    }

    public void addComment(Comment comment) {
        this.comments.add(comment);
        comment.setDocument(this);
    }
}

```

## Best Practices

* **Utilize Business Methods:** Instead of recklessly exposing `@Setter`, create meaningful business methods (e.g., `updateContent()`) that represent domain behaviors to handle state changes.
* **Convenience Methods:** When adding a child entity in a bidirectional `@OneToMany` relationship, you must implement a convenience method that updates the references on both sides.
* **Safe Builder Pattern:** Apply `@Builder` to a custom **constructor** rather than the class level to prevent ID or collection fields from being arbitrarily manipulated externally via the builder.

## Common Pitfalls

* **Reckless use of Lombok:** **NEVER** use `@Data`, `@ToString`, or `@EqualsAndHashCode` on Entity classes. They cause infinite loops (circular references) in bidirectional relationships and cause JPA proxy object equality checks to fail.
* **Leaving EAGER Loading Default:** If the default fetching strategy (EAGER) of `@ManyToOne` is not explicitly changed to `LAZY`, it generates a massive, unpredictable amount of N+1 queries, severely degrading performance.

## Related Skills

* `spring-rest-api`: Use subsequently to implement controllers and core business logic based on the designed entities.
* `spring-querydsl`: Use to write complex dynamic queries and resolve N+1 problems by fetching associated entities at once using `fetchJoin()`.
